<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>Gray-Scott Visualizer (Minimal Fade-In)</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" href="./icon-192.png" type="image/png">
  <meta name="theme-color" content="#000000">
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #fff; font-family: system-ui, sans-serif;
           display: flex; flex-direction: column; align-items: center; padding: 16px; }
    canvas { background: #000; width: 100%; max-width: 500px; aspect-ratio: 1 / 1;
             border-radius: 4px; opacity: 0; transition: opacity 1s ease; pointer-events: none; }
    canvas.active { opacity: 1; pointer-events: auto; }
    #controls { display: flex; flex-direction: column; align-items: stretch; width: 100%;
                max-width: 500px; margin-top: 16px; gap: 8px; }
    #lcd, button { height: 48px; background: #111; border: 1px solid #444; color: #fff;
                   font-size: 16px; font-family: monospace; display: flex; align-items: center;
                   justify-content: center; white-space: nowrap; cursor: pointer; padding: 0 12px;
                   border-radius: 6px; overflow: hidden; text-overflow: ellipsis; }
    #lcd span { display: inline-block; animation: scroll 10s linear infinite; }
    @keyframes scroll { from { transform: translateX(100%); } to { transform: translateX(-100%); } }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <div id="lcd"><span>NO FILES LOADED</span></div>
    <button id="folderButton">SELECT MUSIC FOLDER / FILES</button>
    <button id="playButton">PLAY</button>
    <button id="pauseButton">PAUSE</button>
    <button id="skipButton">NEXT</button>
    <button id="backButton">PREVIOUS</button>
    <input type="file" id="audioInput" accept="audio/*" multiple webkitdirectory>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const size = 500;
    canvas.width = canvas.height = size;
    const imageData = ctx.createImageData(size, size);
    let canvasActivated = false;

    let U = new Float32Array(size * size).fill(1);
    let V = new Float32Array(size * size).fill(0);
    for (let y = size / 2 - 16; y < size / 2 + 16; y++)
      for (let x = size / 2 - 16; x < size / 2 + 16; x++)
        V[y * size + x] = 1;

    const du = 0.16, dv = 0.08;
    let paused = false, playing = false, isSwitching = false;
    let flashFeed = 0, flashKill = 0;
    const pinkNoise = Array(8).fill(0);

    function generatePinkNoise() {
      let total = 0;
      for (let i = 0; i < pinkNoise.length; i++) {
        if (Math.random() < 1 / (1 << i)) pinkNoise[i] = Math.random() * 2 - 1;
        total += pinkNoise[i];
      }
      return total / pinkNoise.length;
    }
    function lap(f, x, y) {
      return f[((y - 1 + size) % size) * size + x] + f[((y + 1) % size) * size + x] +
             f[y * size + ((x - 1 + size) % size)] + f[y * size + ((x + 1) % size)] - 4 * f[y * size + x];
    }
    function step() {
      const U2 = new Float32Array(U.length), V2 = new Float32Array(V.length);
      const t = performance.now() / 1000;
      const pf = generatePinkNoise() * 0.0015, pk = generatePinkNoise() * 0.0015;
      const feedBase = 0.022, killBase = 0.051;
      const f = feedBase + pf + 0.0007 * Math.sin(t * Math.PI / 10) + flashFeed;
      const k = killBase + pk + 0.0007 * Math.cos(t * Math.PI / 10) + flashKill;
      flashFeed *= 0.85; flashKill *= 0.85;
      for (let i = 0; i < U.length; i++) {
        const y = Math.floor(i / size), x = i % size;
        const u = U[i], v = V[i];
        const Lu = lap(U, x, y) * 1.2;
        const Lv = lap(V, x, y) * 1.2;
        U2[i] = u + (du * Lu - u * v * v + f * (1 - u));
        V2[i] = v + (dv * Lv + u * v * v - (f + k) * v);
      }
      U = U2; V = V2;
    }
    function draw() {
      const d = imageData.data;
      const kTone = 3.0;
      const norm = x => Math.max(0, Math.min(1, x));
      const tone = x => (1 - Math.exp(-kTone * x)) / (1 - Math.exp(-kTone));
      for (let i = 0; i < U.length; i++) {
        const base = norm((U[i] - V[i]) * 1.0);
        const t = tone(base);
        const capped = Math.min(t, 0.92);
        const c = (capped * 255) | 0;
        const p = i * 4;
        d[p] = d[p + 1] = d[p + 2] = c; d[p + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
    }
    function loop() {
      if (!paused) {
        let speed = 3;
        if (playing && meyda?._features?.rms)
          speed = Math.min(10, Math.floor(3 + meyda._features.rms * 20));
        for (let i = 0; i < speed; i++) step();
      }
      if (canvasActivated) draw();
      requestAnimationFrame(loop);
    }
    loop();

    canvas.addEventListener('click', () => { flashFeed = 0.02; flashKill = -0.01; });

    /* ====== Audio playback ====== */
    let audioContext, source, meyda;
    let playlist = [], currentTrack = 0;
    let playSessionId = 0;
    const lcdSpan = document.querySelector('#lcd span');

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioContext.onstatechange = () => {
          if (audioContext.state === 'suspended' && playing && !paused) {
            paused = true;
            lcdSpan.textContent = 'PAUSED (system interruption)';
          }
        };
      }
    }
    document.body.addEventListener('touchend', () => {
      if (audioContext?.state === 'suspended') audioContext.resume();
    }, { once: true });

    async function stopCurrentTrack() {
      if (source) {
        try { source.onended = null; } catch {}
        try { source.stop(); } catch {}
        try { source.disconnect(); } catch {}
        source = null;
      }
      playing = false;
      await new Promise(r => setTimeout(r, 50));
    }
    async function loadAudioBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = evt => {
          audioContext.decodeAudioData(evt.target.result).then(resolve).catch(reject);
        };
        reader.readAsArrayBuffer(file);
      });
    }

    function numericFileSort(a, b) {
      const ra = a.name.match(/\d+/);
      const rb = b.name.match(/\d+/);
      if (ra && rb) {
        const na = parseInt(ra[0], 10);
        const nb = parseInt(rb[0], 10);
        if (na !== nb) return na - nb;
      } else if (ra && !rb) return -1;
      else if (!ra && rb) return 1;
      return a.name.localeCompare(b.name, 'ja', { numeric: true, sensitivity: 'base' });
    }
    function nextIndex(idx, dir=+1) {
      const n = playlist.length || 1;
      return (idx + dir + n) % n;
    }

    async function playTrack(index) {
      if (isSwitching || !playlist.length || index >= playlist.length || index < 0) return;
      isSwitching = true;
      const mySession = ++playSessionId;
      try {
        await stopCurrentTrack();
        initAudio();
        const file = playlist[index];
        const buffer = await loadAudioBuffer(file);
        if (!buffer) { lcdSpan.textContent = `Decode failed: ${file.name}`; return; }
        if (mySession !== playSessionId) return;

        source = audioContext.createBufferSource();
        source.buffer = buffer;
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        if (!meyda) {
          meyda = Meyda.createMeydaAnalyzer({
            audioContext, source: analyser, bufferSize: 512,
            featureExtractors: ['rms', 'spectralCentroid'],
            callback: f => { if (!playing || paused) return; }
          });
          meyda.start();
        } else {
          meyda.setSource(analyser);
        }

        source.onended = () => {
          if (mySession !== playSessionId) return;
          if (!paused) {
            playing = false;
            setTimeout(() => playTrack(nextIndex(currentTrack, +1)), 0);
          }
        };

        lcdSpan.textContent = `TRACK ${index + 1}/${playlist.length}: ${file.name}`;
        playing = true; paused = false; currentTrack = index;
        await audioContext.resume();
        source.start(0);

        if (!canvasActivated) { canvas.classList.add('active'); canvasActivated = true; }

      } catch (e) {
        lcdSpan.textContent = `Error: ${e.message}`; console.error(e);
      } finally { isSwitching = false; }
    }

    document.getElementById('playButton').addEventListener('click', () => {
      if (audioContext?.state === 'suspended') audioContext.resume();
      else if (playlist.length) playTrack(currentTrack);
    });
    document.getElementById('pauseButton').addEventListener('click', () => {
      if (audioContext?.state === 'running') { audioContext.suspend(); paused = true; lcdSpan.textContent = 'PAUSED'; }
    });
    document.getElementById('skipButton').addEventListener('click', async () => {
      if (isSwitching || !playlist.length) return;
      await stopCurrentTrack(); await audioContext.resume();
      await playTrack(nextIndex(currentTrack, +1));
    });
    document.getElementById('backButton').addEventListener('click', async () => {
      if (isSwitching || !playlist.length) return;
      await stopCurrentTrack(); await audioContext.resume();
      await playTrack(nextIndex(currentTrack, -1));
    });

    /* ====== Folder / files selection (crossâ€‘platform) ====== */
    const folderButton = document.getElementById('folderButton');
    const audioInput = document.getElementById('audioInput');

    function idbSet(key, value) {
      return new Promise((resolve, reject) => {
        const open = indexedDB.open('gsv-db', 1);
        open.onupgradeneeded = () => open.result.createObjectStore('s');
        open.onsuccess = () => {
          const tx = open.result.transaction('s', 'readwrite');
          tx.objectStore('s').put(value, key);
          tx.oncomplete = () => resolve();
          tx.onerror = reject;
        };
        open.onerror = reject;
      });
    }
    function idbGet(key) {
      return new Promise((resolve, reject) => {
        const open = indexedDB.open('gsv-db', 1);
        open.onupgradeneeded = () => open.result.createObjectStore('s');
        open.onsuccess = () => {
          const tx = open.result.transaction('s', 'readonly');
          const req = tx.objectStore('s').get(key);
          req.onsuccess = () => resolve(req.result);
          req.onerror = reject;
        };
        open.onerror = reject;
      });
    }

    let dirHandle;
    async function pickFolderNative() {
      dirHandle = await window.showDirectoryPicker({ mode: 'read' });
      const perm = await dirHandle.requestPermission({ mode: 'read' });
      if (perm !== 'granted') throw new DOMException('Permission denied');
      await idbSet('musicDir', dirHandle);
      await loadFromDirectoryHandle(dirHandle);
    }

    async function* iterateFilesRecursively(handle) {
      for await (const [name, entry] of handle.entries()) {
        if (entry.kind === 'file') yield await entry.getFile();
        else if (entry.kind === 'directory') yield* iterateFilesRecursively(entry);
      }
    }
    async function loadFromDirectoryHandle(handle) {
      let files = [];
      for await (const f of iterateFilesRecursively(handle)) files.push(f);
      ingestFiles(files);
    }

    function ingestFiles(files) {
      const audios = files.filter(f => (f.type && f.type.startsWith('audio/')) || /\.(mp3|m4a|aac|wav|flac|ogg)$/i.test(f.name));
      audios.sort(numericFileSort);
      playlist = audios;
      currentTrack = 0;
      const txt = playlist.length ? `LOADED ${playlist.length} files` : 'NO FILES';
      lcdSpan.textContent = txt;
    }

    folderButton.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      try {
        if ('showDirectoryPicker' in window) {
          await pickFolderNative();
        } else {
          audioInput.click();
        }
      } catch (err) {
        console.warn('Picker failed, fallback to input:', err);
        audioInput.click();
      }
    });

    audioInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files || []);
      ingestFiles(files);
    });

    (async () => {
      try {
        const h = await idbGet('musicDir');
        if (!h || !('queryPermission' in h)) return;
        const status = await h.queryPermission({ mode: 'read' });
        if (status !== 'granted') {
          const p = await h.requestPermission({ mode: 'read' });
          if (p !== 'granted') return;
        }
        dirHandle = h; await loadFromDirectoryHandle(h);
      } catch {}
    })();

    /* ====== MediaSession & watchdog ====== */
    if ('mediaSession' in navigator) {
      navigator.mediaSession.setActionHandler('play', () => { audioContext?.resume(); paused = false; lcdSpan.textContent = 'PLAYING'; });
      navigator.mediaSession.setActionHandler('pause', () => { audioContext?.suspend(); paused = true; lcdSpan.textContent = 'PAUSED'; });
      navigator.mediaSession.setActionHandler('previoustrack', () => { document.getElementById('backButton').click(); });
      navigator.mediaSession.setActionHandler('nexttrack', () => { document.getElementById('skipButton').click(); });
    }
    setInterval(() => {
      if (document.visibilityState !== 'visible') return;
      if (paused) return;
      if (playing && audioContext && audioContext.state !== 'running') {
        audioContext.resume().catch(()=>{});
      }
    }, 30000);

    function autoPause(reason) {
      try { if (audioContext?.state === 'running') audioContext.suspend(); } catch {}
      paused = true;
      if (reason) lcdSpan.textContent = `PAUSED (${reason})`;
    }
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState !== 'visible') autoPause('background');
    });
    window.addEventListener('pagehide', () => autoPause('background'));

    if (navigator.mediaDevices && 'addEventListener' in navigator.mediaDevices) {
      navigator.mediaDevices.addEventListener('devicechange', () => {
        if (playing && !paused) autoPause('device change');
      });
    }

    let wakeLock;
    async function enableWakeLock() {
      try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch {}
    }
    enableWakeLock();
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && 'wakeLock' in navigator) {
        try { wakeLock = await navigator.wakeLock.request('screen'); } catch {}
      }
    });
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js?ver=14').catch(console.error);
      });
    }
  </script>
</body>
</html>
