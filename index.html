<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>Gray-Scott Visualizer (Final — Hard Stop, No Abort)</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" href="./icon-192.png" type="image/png">
  <meta name="theme-color" content="#000000">
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #fff; font-family: system-ui, sans-serif;
           display: flex; flex-direction: column; align-items: center; padding: 16px; }
    canvas { background: #000; width: 100%; max-width: 500px; aspect-ratio: 1 / 1;
             border-radius: 6px; opacity: 0; transition: opacity 0.8s ease; pointer-events: none; }
    canvas.active { opacity: 1; pointer-events: auto; }
    #controls { display: flex; flex-direction: column; align-items: stretch; width: 100%;
                max-width: 500px; margin-top: 16px; gap: 8px; }
    #lcd, button { height: 48px; background: #111; border: 1px solid #444; color: #fff;
                   font-size: 16px; font-family: monospace; display: flex; align-items: center;
                   justify-content: center; white-space: nowrap; cursor: pointer; padding: 0 12px;
                   border-radius: 8px; overflow: hidden; text-overflow: ellipsis; }
    #lcd small { opacity: .7; margin-left: 8px; font-size: 12px; }
    #lcd span { display: inline-block; animation: scroll 12s linear infinite; }
    @keyframes scroll { from { transform: translateX(100%); } to { transform: translateX(-100%); } }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <div id="lcd"><span>NO FILES LOADED</span></div>
    <button id="folderButton">SELECT MUSIC FOLDER / FILES</button>
    <button id="playButton">PLAY</button>
    <button id="pauseButton">PAUSE</button>
    <button id="skipButton">NEXT</button>
    <button id="backButton">PREVIOUS</button>
    <input type="file" id="audioInput" accept="audio/*" multiple webkitdirectory>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
  <script>
    /* ========= Visualizer ========= */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const size = 500;
    canvas.width = canvas.height = size;
    const imageData = ctx.createImageData(size, size);
    let canvasActivated = false;

    let U = new Float32Array(size * size).fill(1);
    let V = new Float32Array(size * size).fill(0);
    for (let y = size / 2 - 16; y < size / 2 + 16; y++)
      for (let x = size / 2 - 16; x < size / 2 + 16; x++)
        V[y * size + x] = 1;

    const du = 0.16, dv = 0.08;
    let audioPaused = true;
    let isSwitching = false;
    let flashFeed = 0, flashKill = 0;
    const pinkNoise = Array(8).fill(0);

    function generatePinkNoise() {
      let total = 0;
      for (let i = 0; i < pinkNoise.length; i++) {
        if (Math.random() < 1 / (1 << i)) pinkNoise[i] = Math.random() * 2 - 1;
        total += pinkNoise[i];
      }
      return total / pinkNoise.length;
    }
    function lap(f, x, y) {
      return f[((y - 1 + size) % size) * size + x] + f[((y + 1) % size) * size + x] +
             f[y * size + ((x - 1 + size) % size)] + f[y * size + ((x + 1) % size)] - 4 * f[y * size + x];
    }
    function step() {
      const U2 = new Float32Array(U.length), V2 = new Float32Array(V.length);
      const t = performance.now() / 1000;
      const pf = generatePinkNoise() * 0.0015, pk = generatePinkNoise() * 0.0015;
      const feedBase = 0.022, killBase = 0.051;
      const f = feedBase + pf + 0.0007 * Math.sin(t * Math.PI / 10) + flashFeed;
      const k = killBase + pk + 0.0007 * Math.cos(t * Math.PI / 10) + flashKill;
      flashFeed *= 0.85; flashKill *= 0.85;
      for (let i = 0; i < U.length; i++) {
        const y = Math.floor(i / size), x = i % size;
        const u = U[i], v = V[i];
        const Lu = lap(U, x, y) * 1.2;
        const Lv = lap(V, x, y) * 1.2;
        U2[i] = u + (du * Lu - u * v * v + f * (1 - u));
        V2[i] = v + (dv * Lv + u * v * v - (f + k) * v);
      }
      U = U2; V = V2;
    }
    function draw() {
      const d = imageData.data;
      const kTone = 3.0;
      const norm = x => Math.max(0, Math.min(1, x));
      const tone = x => (1 - Math.exp(-kTone * x)) / (1 - Math.exp(-kTone));
      for (let i = 0; i < U.length; i++) {
        const base = norm((U[i] - V[i]) * 1.0);
        const t = tone(base);
        const capped = Math.min(t, 0.92);
        const c = (capped * 255) | 0;
        const p = i * 4;
        d[p] = d[p + 1] = d[p + 2] = c; d[p + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
    }
    function loop() { for (let i = 0; i < 3; i++) step(); draw(); requestAnimationFrame(loop); }
    loop();
    canvas.addEventListener('click', () => { flashFeed = 0.02; flashKill = -0.01; });

    /* ========= Audio ========= */
    let audioContext, source, meyda, masterGain;
    let playlist = [], currentTrack = 0, playing = false;
    let playSessionId = 0, stopToken = 0, loadToken = 0;
    const lcdSpan = document.querySelector('#lcd span');
    const lcd = t => (lcdSpan.textContent = t);
    const lcdTrack = () => playlist.length ? lcd(`TRACK ${currentTrack+1}/${playlist.length}: ${playlist[currentTrack].name}`) : lcd('NO FILES');
    const lcdPaused = () => playlist.length ? lcd(`PAUSED — TRACK ${currentTrack+1}/${playlist.length}: ${playlist[currentTrack].name}`) : lcd('PAUSED');

    function ensureContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.value = 1.0;
        masterGain.connect(audioContext.destination);
        audioContext.onstatechange = () => {
          if (audioContext.state === 'suspended' && playing && !audioPaused) {
            audioPaused = true; lcdPaused();
          }
        };
      }
    }

    async function softKillPlayback() {
      // Stop current source and detach nodes; keep AudioContext alive
      stopToken++;
      if (source) {
        try { source.onended = null; } catch {}
        try { source.stop(0); } catch {}
        try { source.disconnect(); } catch {}
        source = null;
      }
      if (meyda) { try { meyda.stop(); } catch {} meyda = null; }
      if (masterGain) { try { masterGain.disconnect(); } catch {} }
      if (audioContext) {
        try { await audioContext.suspend(); } catch {}
      }
      if (audioContext) { // rebuild masterGain chain after suspend
        try {
          masterGain = audioContext.createGain();
          masterGain.gain.value = 1.0;
          masterGain.connect(audioContext.destination);
        } catch {}
      }
      playing = false; audioPaused = true;
      await new Promise(r => setTimeout(r, 12));
    }

    document.body.addEventListener('touchend', () => {
      if (audioContext?.state === 'suspended' && !audioPaused) audioContext.resume();
    }, { once: true });

    async function loadAudioBuffer(file, myLoad) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = evt => {
          if (myLoad !== loadToken) return reject(new DOMException('aborted','AbortError'));
          ensureContext();
          audioContext.decodeAudioData(evt.target.result).then(b => {
            if (myLoad !== loadToken) reject(new DOMException('aborted','AbortError'));
            else resolve(b);
          }).catch(reject);
        };
        reader.readAsArrayBuffer(file);
      });
    }

    function numericFileSort(a, b) {
      const ra=a.name.match(/\d+/), rb=b.name.match(/\d+/);
      if (ra && rb) { const na=+ra[0], nb=+rb[0]; if (na!==nb) return na-nb; }
      else if (ra && !rb) return -1; else if (!ra && rb) return 1;
      return a.name.localeCompare(b.name, 'ja', { numeric:true, sensitivity:'base' });
    }
    const nextIndex = (i,d=+1)=> (i + d + (playlist.length||1)) % (playlist.length||1);

    async function playTrack(index) {
      if (isSwitching || !playlist.length || index<0 || index>=playlist.length) return;
      isSwitching = true;
      const mySession = ++playSessionId;
      const myStop = stopToken;
      const myLoad = loadToken;
      try {
        await softKillPlayback();  // do not bump tokens; keep context alive
        ensureContext();
        const file = playlist[index];
        const buffer = await loadAudioBuffer(file, myLoad);
        if (mySession !== playSessionId || myStop !== stopToken || myLoad !== loadToken) return;

        source = audioContext.createBufferSource();
        source.buffer = buffer;
        const analyser = audioContext.createAnalyser(); analyser.fftSize = 1024;
        source.connect(analyser); analyser.connect(masterGain || audioContext.destination);

        if (!meyda) {
          meyda = Meyda.createMeydaAnalyzer({
            audioContext, source: analyser, bufferSize: 512,
            featureExtractors: ['rms','spectralCentroid'],
            callback: () => {}
          }); try { meyda.start(); } catch {}
        } else { meyda.setSource(analyser); }

        source.onended = () => {
          if (mySession !== playSessionId || myStop !== stopToken || myLoad !== loadToken) return;
          if (!audioPaused) setTimeout(() => playTrack(nextIndex(currentTrack,+1)), 0);
        };

        currentTrack = index; lcdTrack();
        playing = true; audioPaused = false;
        await audioContext.resume(); source.start(0);
        if (!canvasActivated) { canvas.classList.add('active'); canvasActivated = true; }
      } catch (e) { lcd(`Error: ${e.message}`); console.error(e); }
      finally { isSwitching = false; }
    }

    /* controls */
    playButton.addEventListener('click', () => {
      requestWakeLock();
      if (!playlist.length) return;
      if (!source) playTrack(currentTrack);
      else { audioPaused=false; ensureContext(); audioContext?.resume().then(lcdTrack).catch(()=>{}); }
    });
    pauseButton.addEventListener('click', async () => {
      audioPaused = true; lcdPaused();
      await softKillPlayback();
    });
    skipButton.addEventListener('click', async () => {
      if (!playlist.length) return;
      await softKillPlayback();
      await playTrack(nextIndex(currentTrack,+1));
    });
    backButton.addEventListener('click', async () => {
      if (!playlist.length) return;
      await softKillPlayback();
      await playTrack(nextIndex(currentTrack,-1));
    });

    /* ========= Picker ========= */
    const folderButton = document.getElementById('folderButton');
    const audioInput  = document.getElementById('audioInput');

    function idbOpen(){return new Promise((res,rej)=>{const o=indexedDB.open('gsv-db',1);o.onupgradeneeded=()=>o.result.createObjectStore('s');o.onsuccess=()=>res(o.result);o.onerror=rej;});}
    async function idbSet(k,v){const db=await idbOpen();return new Promise((res,rej)=>{const tx=db.transaction('s','readwrite');tx.objectStore('s').put(v,k);tx.oncomplete=res;tx.onerror=rej;});}
    async function idbGet(k){const db=await idbOpen();return new Promise((res,rej)=>{const tx=db.transaction('s','readonly');const r=tx.objectStore('s').get(k);r.onsuccess=()=>res(r.result);r.onerror=rej;});}
    async function idbDel(k){const db=await idbOpen();return new Promise((res,rej)=>{const tx=db.transaction('s','readwrite');tx.objectStore('s').delete(k);tx.oncomplete=res;tx.onerror=rej;});}

    let dirHandle;

    async function replacePlaylistWith(files,label='') {
      // Invalidate pending async (decode/onended), and hard-stop current source
      loadToken++; playSessionId++; // new session expected after replace
      await softKillPlayback();
      const audios = files.filter(f => (f.type && f.type.startsWith('audio/')) || /\.(mp3|m4a|aac|wav|flac|ogg)$/i.test(f.name));
      audios.sort(numericFileSort);
      playlist = audios; currentTrack = 0; audioPaused = true; playing = false;
      lcd(playlist.length ? `LOADED ${playlist.length} files${label?' — '+label:''}` : 'NO FILES');
    }

    async function* walk(handle){
      for await (const [name,entry] of handle.entries()){
        if (entry.kind==='file') yield await entry.getFile();
        else if (entry.kind==='directory') yield* walk(entry);
      }
    }
    async function loadFromDir(h){
      const files=[]; for await (const f of walk(h)) files.push(f);
      await replacePlaylistWith(files, h?.name||'');
    }
    async function pickFolderNative(){
      const h = await window.showDirectoryPicker({mode:'read'});
      const p = await h.requestPermission({mode:'read'}); if (p!=='granted') throw new DOMException('Permission denied');
      dirHandle=h; await idbSet('musicDir',h); await loadFromDir(h);
    }

    folderButton.addEventListener('click', async (e)=>{
      e.preventDefault(); e.stopPropagation();
      requestWakeLock();
      try{
        if ('showDirectoryPicker' in window) { await pickFolderNative(); }
        else { audioInput.click(); }
      }catch(err){ console.warn('Picker failed, fallback:', err); audioInput.click(); }
    });
    audioInput.addEventListener('change', async (e)=>{
      const files = Array.from(e.target.files||[]);
      await idbDel('musicDir'); dirHandle=null;
      await replacePlaylistWith(files);
    });

    // restore (desktop)
    (async()=>{
      try{
        const h = await idbGet('musicDir');
        if (!h || !('queryPermission' in h)) return;
        const st = await h.queryPermission({mode:'read'});
        if (st!=='granted'){ const p = await h.requestPermission({mode:'read'}); if (p!=='granted') return; }
        dirHandle=h; await loadFromDir(h);
      }catch{}
    })();

    /* ========= Background policy ========= */
    function autoPause(reason){
      audioPaused = true;
      softKillPlayback();
      lcd(reason==='background' ? 'PAUSED (background)' : 'PAUSED');
    }
    document.addEventListener('visibilitychange',()=>{
      if (document.visibilityState==='hidden') autoPause('background');
      if (document.visibilityState==='visible' && audioPaused) lcdPaused();
    });
    window.addEventListener('pagehide',()=>autoPause('background'));

    /* ========= Wake Lock ========= */
    let wakeLock = null, wakeRetryTimer = null;
    async function requestWakeLock() {
      try {
        if (!('wakeLock' in navigator)) return;
        if (wakeLock) return;
        wakeLock = await navigator.wakeLock.request('screen');
        if (!document.querySelector('#lcd small')) lcdSpan.insertAdjacentHTML('beforeend','<small>• screen on</small>');
        wakeLock.addEventListener('release', () => {
          wakeLock = null;
          clearTimeout(wakeRetryTimer);
          wakeRetryTimer = setTimeout(() => { requestWakeLock(); }, 500);
        });
      } catch (e) {
        clearTimeout(wakeRetryTimer);
        wakeRetryTimer = setTimeout(() => { requestWakeLock(); }, 1000);
      }
    }
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') requestWakeLock();
    });
    ['click','touchstart'].forEach(ev => document.addEventListener(ev, requestWakeLock, { once: true }));

    /* ========= MediaSession ========= */
    if ('mediaSession' in navigator){
      navigator.mediaSession.setActionHandler('play',()=>{
        if (!playlist.length) return;
        audioPaused=false; ensureContext(); audioContext?.resume().then(lcdTrack).catch(()=>{});
      });
      navigator.mediaSession.setActionHandler('pause',()=>{
        audioPaused=true; softKillPlayback().then(lcdPaused);
      });
      navigator.mediaSession.setActionHandler('previoustrack',()=>backButton.click());
      navigator.mediaSession.setActionHandler('nexttrack',()=>skipButton.click());
    }
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js?ver=21').catch(console.error);
      });
    }
  </script>
</body>
</html>
