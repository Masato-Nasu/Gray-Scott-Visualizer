<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>Gray-Scott Visualizer — Gesture-Safe Playback</title>
  <meta name="theme-color" content="#000000">
  <style>
    html,body{height:100%} body{margin:0;background:#000;color:#fff;font-family:system-ui,sans-serif;display:flex;flex-direction:column;align-items:center;padding:16px}
    canvas{background:#000;width:100%;max-width:500px;aspect-ratio:1/1;border-radius:6px;opacity:0;transition:opacity .8s ease;pointer-events:none}
    canvas.active{opacity:1;pointer-events:auto}
    #controls{display:flex;flex-direction:column;align-items:stretch;width:100%;max-width:500px;margin-top:16px;gap:8px}
    #lcd,button{height:48px;background:#111;border:1px solid #444;color:#fff;font-size:16px;font-family:monospace;display:flex;align-items:center;justify-content:center;white-space:nowrap;cursor:pointer;padding:0 12px;border-radius:8px;overflow:hidden;text-overflow:ellipsis}
    #lcd span{display:inline-block;animation:scroll 12s linear infinite}
    @keyframes scroll{from{transform:translateX(100%)}to{transform:translateX(-100%)}}
    input[type=file]{display:none}
    audio{display:none}
    /* resume overlay */
    #resumeOverlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:999}
    #resumeOverlay button{min-width:240px;height:56px;font-size:18px;border-radius:10px;background:#0fd;color:#000;border:none}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <div id="lcd"><span>NO FILES LOADED</span></div>
    <button id="folderBtn">SELECT MUSIC FOLDER / FILES</button>
    <button id="playBtn">PLAY</button>
    <button id="pauseBtn">PAUSE</button>
    <button id="nextBtn">NEXT</button>
    <button id="prevBtn">PREVIOUS</button>
    <input type="file" id="fileInput" accept="audio/*" multiple webkitdirectory>
  </div>
  <div id="resumeOverlay"><button id="resumeBtn">TAP TO RESUME</button></div>
  <audio id="player" preload="metadata" playsinline></audio>

  <script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
  <script>
  /* ===== Visualizer ===== */
  const canvas=document.getElementById('canvas'); const ctx=canvas.getContext('2d'); const size=500; canvas.width=canvas.height=size;
  const imageData=ctx.createImageData(size,size); let canvasActivated=false;
  let U=new Float32Array(size*size).fill(1), V=new Float32Array(size*size).fill(0);
  for(let y=size/2-16; y<size/2+16; y++) for(let x=size/2-16; x<size/2+16; x++) V[y*size+x]=1;
  const du=.16,dv=.08; let flashFeed=0,flashKill=0; const pink=Array(8).fill(0);
  const pn=()=>{let t=0; for(let i=0;i<pink.length;i++){ if(Math.random()<1/(1<<i)) pink[i]=Math.random()*2-1; t+=pink[i]; } return t/pink.length; };
  const lap=(f,x,y)=>f[((y-1+size)%size)*size+x]+f[((y+1)%size)*size+x]+f[y*size+((x-1+size)%size)]+f[y*size+((x+1)%size)]-4*f[y*size+x];
  function step(){ const U2=new Float32Array(U.length), V2=new Float32Array(V.length); const t=performance.now()/1000;
    const f=.022+pn()*.0015+.0007*Math.sin(t*Math.PI/10)+flashFeed, k=.051+pn()*.0015+.0007*Math.cos(t*Math.PI/10)+flashKill;
    flashFeed*=.85; flashKill*=.85;
    for(let i=0;i<U.length;i++){ const y=(i/size)|0,x=i%size,u=U[i],v=V[i]; const Lu=lap(U,x,y)*1.2,Lv=lap(V,x,y)*1.2; U2[i]=u+(du*Lu-u*v*v+f*(1-u)); V2[i]=v+(dv*Lv+u*v*v-(f+k)*v); }
    U=U2; V=V2;
  }
  function draw(){ const d=imageData.data,k=3,n=x=>Math.max(0,Math.min(1,x)),t=x=>(1-Math.exp(-k*x))/(1-Math.exp(-k));
    for(let i=0;i<U.length;i++){ const c=(Math.min(t(n((U[i]-V[i])*1.0)),.92)*255)|0; const p=i*4; d[p]=d[p+1]=d[p+2]=c; d[p+3]=255; }
    ctx.putImageData(imageData,0,0);
  }
  (function loop(){ for(let i=0;i<3;i++) step(); draw(); requestAnimationFrame(loop); })();
  canvas.addEventListener('click',()=>{ flashFeed=.02; flashKill=-.01; });

  /* ===== Playback (HTMLAudioElement) ===== */
  const player=document.getElementById('player');
  let playlist=[], urls=[], cur=0, autoPaused=false, savedTime=0;
  let audioCtx=null, mediaSrc=null, analyser=null, meyda=null;
  const lcdSpan=document.querySelector('#lcd span'); const lcd=t=>lcdSpan.innerHTML=t;
  const nowText=()=>playlist.length?`TRACK ${cur+1}/${playlist.length}: ${playlist[cur].name}`:'NO FILES';

  function sortNumeric(files){
    return files.sort((a,b)=>{
      const ra=a.name.match(/\d+/), rb=b.name.match(/\d+/);
      if(ra&&rb){const na=+ra[0], nb=+rb[0]; if(na!==nb) return na-nb;}
      else if(ra&&!rb) return -1; else if(!ra&&rb) return 1;
      return a.name.localeCompare(b.name,'ja',{numeric:true,sensitivity:'base'});
    });
  }
  function revokeAll(){ urls.forEach(u=>URL.revokeObjectURL(u)); urls=[]; }
  async function replacePlaylist(files,label=''){
    player.pause(); savedTime=0; autoPaused=false;
    revokeAll();
    playlist = sortNumeric(files.filter(f => (f.type && f.type.startsWith('audio/')) || /\.(mp3|m4a|aac|wav|flac|ogg)$/i.test(f.name)));
    urls = playlist.map(f=>URL.createObjectURL(f));
    cur=0; player.src=''; lcd(playlist.length?`LOADED ${playlist.length} files${label?' — '+label:''}`:'NO FILES');
  }

  // Build analyser graph only once, *after* first successful play (gesture)
  function ensureGraph(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    mediaSrc = audioCtx.createMediaElementSource(player);
    analyser = audioCtx.createAnalyser(); analyser.fftSize=1024;
    mediaSrc.connect(analyser); analyser.connect(audioCtx.destination);
    meyda = Meyda.createMeydaAnalyzer({ audioContext: audioCtx, source: analyser, bufferSize: 512, featureExtractors: ['rms','spectralCentroid'], callback: ()=>{} });
    try { meyda.start(); } catch {}
  }

  async function play(index=cur, resumeFromSaved=false){
    if(!playlist.length) return;
    cur = Math.max(0, Math.min(index, playlist.length-1));
    const needNewSrc = (player.src !== urls[cur]);
    if (needNewSrc) { player.src = urls[cur]; }
    if (resumeFromSaved && savedTime > 0) {
      // seek after metadata
      if (player.readyState < 1) {
        await new Promise(r => { const on=()=>{ player.removeEventListener('loadedmetadata', on); r(); }; player.addEventListener('loadedmetadata', on); });
      }
      try { player.currentTime = savedTime; } catch {}
    }
    try {
      await player.play(); // must be in a gesture handler
      ensureGraph(); try{ await audioCtx.resume(); }catch{}
      lcd(nowText()); savedTime = 0; autoPaused=false;
      if(!canvasActivated){ canvas.classList.add('active'); canvasActivated=true; }
    } catch (e) {
      showResumeOverlay(); // ask for a tap
    }
  }
  function pauseManual(){ savedTime = player.currentTime || 0; player.pause(); autoPaused=false; lcd(`PAUSED — ${nowText()}`); }

  // Next/Prev wire
  player.addEventListener('ended', ()=>{ play((cur+1)%playlist.length); });

  // UI elements
  const folderBtn=document.getElementById('folderBtn');
  const fileInput=document.getElementById('fileInput');
  document.getElementById('playBtn').addEventListener('click', ()=> play(cur, !!savedTime));
  document.getElementById('pauseBtn').addEventListener('click', pauseManual);
  document.getElementById('nextBtn').addEventListener('click', ()=> play((cur+1)%playlist.length));
  document.getElementById('prevBtn').addEventListener('click', ()=> play((cur-1+playlist.length)%playlist.length));

  // Folder pickers
  async function* walk(h){ for await (const [name,e] of h.entries()){ if(e.kind==='file') yield await e.getFile(); else if(e.kind==='directory') yield* walk(e);} }
  async function loadFromDir(h){ const files=[]; for await(const f of walk(h)) files.push(f); await replacePlaylist(files, h?.name||''); }
  async function pickFolderNative(){ const h=await window.showDirectoryPicker({mode:'read'}); const p=await h.requestPermission({mode:'read'}); if(p!=='granted') throw new DOMException('Permission denied'); await loadFromDir(h); }
  folderBtn.addEventListener('click', async (e)=>{
    e.preventDefault(); e.stopPropagation();
    try { if('showDirectoryPicker' in window){ await pickFolderNative(); } else { fileInput.click(); } }
    catch { fileInput.click(); }
  });
  fileInput.addEventListener('change', async (e)=>{ const files=[...e.target.files||[]]; await replacePlaylist(files); });

  // Background policy: pause and remember time; require explicit tap to resume (reliable across devices)
  const overlay=document.getElementById('resumeOverlay'), resumeBtn=document.getElementById('resumeBtn');
  function showResumeOverlay(){ overlay.style.display='flex'; }
  function hideResumeOverlay(){ overlay.style.display='none'; }
  resumeBtn.addEventListener('click', async ()=>{ hideResumeOverlay(); await play(cur, true); });

  document.addEventListener('visibilitychange', ()=>{
    if(document.visibilityState==='hidden'){
      if(!player.paused){ savedTime = player.currentTime || 0; player.pause(); autoPaused=true; lcd('PAUSED (background)'); }
    } else {
      if(autoPaused){ showResumeOverlay(); } // request a gesture to comply with policies
    }
  });
  window.addEventListener('pagehide', ()=>{ if(!player.paused){ savedTime = player.currentTime || 0; player.pause(); autoPaused=true; lcd('PAUSED (background)'); } });

  // Small UX: tap LCD to resume when overlay not visible
  document.getElementById('lcd').addEventListener('click', ()=>{ if(autoPaused) showResumeOverlay(); });

  </script>
</body>
</html>
