<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>Gray-Scott Visualizer — Auto-Resume w/ Gesture Fallback</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" href="./icon-192.png" type="image/png">
  <meta name="theme-color" content="#000000">
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #fff; font-family: system-ui, sans-serif;
           display: flex; flex-direction: column; align-items: center; padding: 16px; }
    canvas { background: #000; width: 100%; max-width: 500px; aspect-ratio: 1 / 1;
             border-radius: 6px; opacity: 0; transition: opacity 0.8s ease; pointer-events: none; }
    canvas.active { opacity: 1; pointer-events: auto; }
    #controls { display: flex; flex-direction: column; align-items: stretch; width: 100%;
                max-width: 500px; margin-top: 16px; gap: 8px; }
    #lcd, button { height: 48px; background: #111; border: 1px solid #444; color: #fff;
                   font-size: 16px; font-family: monospace; display: flex; align-items: center;
                   justify-content: center; white-space: nowrap; cursor: pointer; padding: 0 12px;
                   border-radius: 8px; overflow: hidden; text-overflow: ellipsis; }
    #lcd strong { color: #0fd; }
    #lcd small { opacity: .7; margin-left: 8px; font-size: 12px; }
    #lcd span { display: inline-block; animation: scroll 12s linear infinite; }
    @keyframes scroll { from { transform: translateX(100%); } to { transform: translateX(-100%); } }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <div id="lcd"><span>NO FILES LOADED</span></div>
    <button id="folderButton">SELECT MUSIC FOLDER / FILES</button>
    <button id="playButton">PLAY</button>
    <button id="pauseButton">PAUSE</button>
    <button id="skipButton">NEXT</button>
    <button id="backButton">PREVIOUS</button>
    <input type="file" id="audioInput" accept="audio/*" multiple webkitdirectory>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const size = 500; canvas.width = canvas.height = size;
    const imageData = ctx.createImageData(size, size);
    let canvasActivated = false;

    let U = new Float32Array(size * size).fill(1);
    let V = new Float32Array(size * size).fill(0);
    for (let y = size/2-16; y < size/2+16; y++) for (let x = size/2-16; x < size/2+16; x++) V[y*size+x] = 1;

    const du=0.16, dv=0.08; let flashFeed=0, flashKill=0;
    const pink = Array(8).fill(0);
    const pn = () => { let t=0; for(let i=0;i<pink.length;i++){ if(Math.random()<1/(1<<i)) pink[i]=Math.random()*2-1; t+=pink[i]; } return t/pink.length; };
    const lap=(f,x,y)=>f[((y-1+size)%size)*size+x]+f[((y+1)%size)*size+x]+f[y*size+((x-1+size)%size)]+f[y*size+((x+1)%size)]-4*f[y*size+x];
    function step(){ const U2=new Float32Array(U.length), V2=new Float32Array(V.length); const t=performance.now()/1000;
      const f=0.022 + pn()*0.0015 + 0.0007*Math.sin(t*Math.PI/10) + flashFeed;
      const k=0.051 + pn()*0.0015 + 0.0007*Math.cos(t*Math.PI/10) + flashKill;
      flashFeed*=0.85; flashKill*=0.85;
      for(let i=0;i<U.length;i++){ const y=(i/size)|0, x=i%size; const u=U[i], v=V[i];
        const Lu=lap(U,x,y)*1.2, Lv=lap(V,x,y)*1.2; U2[i]=u+(du*Lu-u*v*v+f*(1-u)); V2[i]=v+(dv*Lv+u*v*v-(f+k)*v); }
      U=U2; V=V2;
    }
    function draw(){ const d=imageData.data, k=3; const n=x=>Math.max(0,Math.min(1,x)), t=x=>(1-Math.exp(-k*x))/(1-Math.exp(-k));
      for(let i=0;i<U.length;i++){ const c=(Math.min(t(n((U[i]-V[i])*1.0)),0.92)*255)|0; const p=i*4; d[p]=d[p+1]=d[p+2]=c; d[p+3]=255; }
      ctx.putImageData(imageData,0,0);
    }
    (function loop(){ for(let i=0;i<3;i++) step(); draw(); requestAnimationFrame(loop); })();
    canvas.addEventListener('click',()=>{ flashFeed=0.02; flashKill=-0.01; });

    /* ======= Audio & UI ======= */
    let audioContext, source, meyda, masterGain;
    let playlist=[], currentTrack=0, playing=false, audioPaused=true;
    let playSessionId=0, stopToken=0, loadToken=0;
    let trackBuffer=null, startedAtCtxTime=0, pausedOffsetSec=0, autoPausedByBackground=false;
    const lcdSpan=document.querySelector('#lcd span');
    const lcd=t=>lcdSpan.textContent=t;
    const lcdTrack=()=>playlist.length?lcd(`TRACK ${currentTrack+1}/${playlist.length}: ${playlist[currentTrack].name}`):lcd('NO FILES');
    const lcdPaused=()=>playlist.length?lcd(`PAUSED — TRACK ${currentTrack+1}/${playlist.length}: ${playlist[currentTrack].name}`):lcd('PAUSED');

    function ensureContext(){
      if(!audioContext){
        audioContext=new (window.AudioContext||window.webkitAudioContext)();
        masterGain=audioContext.createGain(); masterGain.gain.value=1.0; masterGain.connect(audioContext.destination);
      }
    }
    async function softKill(){ stopToken++; if(source){ try{source.onended=null;}catch{} try{source.stop(0);}catch{} try{source.disconnect();}catch{} source=null; }
      if(meyda){ try{meyda.stop();}catch{} meyda=null; }
      if(audioContext){ try{ await audioContext.suspend(); }catch{} }
      playing=false; audioPaused=true; }

    function numericFileSort(a,b){const ra=a.name.match(/\d+/),rb=b.name.match(/\d+/);
      if(ra&&rb){const na=+ra[0],nb=+rb[0]; if(na!==nb)return na-nb;} else if(ra&&!rb)return -1; else if(!ra&&rb)return 1;
      return a.name.localeCompare(b.name,'ja',{numeric:true,sensitivity:'base'}); }
    const nextIndex=(i,d=+1)=>(i+d+(playlist.length||1))%(playlist.length||1);

    async function loadBuffer(file,myLoad){ return new Promise((resolve,reject)=>{
      const reader=new FileReader();
      reader.onload=e=>{ if(myLoad!==loadToken) return reject(new DOMException('aborted','AbortError'));
        ensureContext(); audioContext.decodeAudioData(e.target.result).then(b=>{
          if(myLoad!==loadToken) reject(new DOMException('aborted','AbortError')); else resolve(b);
        }).catch(reject);
      }; reader.readAsArrayBuffer(file);
    }); }

    async function playTrack(index, offset=0){
      if(!playlist.length || index<0 || index>=playlist.length) return;
      const mySession=++playSessionId, myStop=stopToken, myLoad=loadToken;
      await softKill(); ensureContext();
      const file=playlist[index];
      const buf=(trackBuffer && index===currentTrack && offset>0) ? trackBuffer : await loadBuffer(file,myLoad);
      if(mySession!==playSessionId||myStop!==stopToken||myLoad!==loadToken) return;
      trackBuffer=buf;
      source=audioContext.createBufferSource(); source.buffer=buf;
      const analyser=audioContext.createAnalyser(); analyser.fftSize=1024;
      source.connect(analyser); analyser.connect(masterGain||audioContext.destination);
      if(!meyda){ meyda=Meyda.createMeydaAnalyzer({audioContext, source:analyser, bufferSize:512, featureExtractors:['rms','spectralCentroid'], callback:()=>{}}); try{meyda.start();}catch{} }
      else { meyda.setSource(analyser); }
      source.onended=()=>{ if(mySession!==playSessionId||myStop!==stopToken||myLoad!==loadToken) return; if(!audioPaused) setTimeout(()=>playTrack(nextIndex(currentTrack,+1),0),0); };
      currentTrack=index; startedAtCtxTime = (audioContext.currentTime - offset); lcdTrack();
      playing=true; audioPaused=false; await audioContext.resume(); source.start(0, offset);
      if(!canvasActivated){ canvas.classList.add('active'); canvasActivated=true; }
    }

    const folderButton=document.getElementById('folderButton');
    const audioInput=document.getElementById('audioInput');
    const playButton=document.getElementById('playButton');
    const pauseButton=document.getElementById('pauseButton');
    const skipButton=document.getElementById('skipButton');
    const backButton=document.getElementById('backButton');

    playButton.addEventListener('click',()=>{ requestWakeLock();
      if(!playlist.length) return;
      const offset = (autoPausedByBackground || pausedOffsetSec>0) ? pausedOffsetSec : 0;
      autoPausedByBackground=false; pausedOffsetSec=0;
      if(!source) playTrack(currentTrack, offset); else { audioPaused=false; ensureContext(); audioContext?.resume().then(lcdTrack).catch(()=>{}); } });
    pauseButton.addEventListener('click',async()=>{ if(audioContext&&source&&trackBuffer){ pausedOffsetSec=Math.max(0,audioContext.currentTime-startedAtCtxTime); }
      autoPausedByBackground=false; audioPaused=true; lcdPaused(); await softKill(); });
    skipButton.addEventListener('click',async()=>{ pausedOffsetSec=0; autoPausedByBackground=false; await softKill(); await playTrack(nextIndex(currentTrack,+1),0); });
    backButton.addEventListener('click',async()=>{ pausedOffsetSec=0; autoPausedByBackground=false; await softKill(); await playTrack(nextIndex(currentTrack,-1),0); });

    function idbOpen(){return new Promise((res,rej)=>{const o=indexedDB.open('gsv-db',1);o.onupgradeneeded=()=>o.result.createObjectStore('s');o.onsuccess=()=>res(o.result);o.onerror=rej;});}
    async function idbSet(k,v){const db=await idbOpen();return new Promise((res,rej)=>{const tx=db.transaction('s','readwrite');tx.objectStore('s').put(v,k);tx.oncomplete=res;tx.onerror=rej;});}
    async function idbGet(k){const db=await idbOpen();return new Promise((res,rej)=>{const tx=db.transaction('s','readonly');const r=tx.objectStore('s').get(k);r.onsuccess=()=>res(r.result);r.onerror=rej;});}
    async function idbDel(k){const db=await idbOpen();return new Promise((res,rej)=>{const tx=db.transaction('s','readwrite');tx.objectStore('s').delete(k);tx.oncomplete=res;tx.onerror=rej;});}

    let dirHandle;
    async function replacePlaylist(files,label=''){ loadToken++; playSessionId++; await softKill(); trackBuffer=null; pausedOffsetSec=0; autoPausedByBackground=false;
      const audios=files.filter(f=>(f.type&&f.type.startsWith('audio/'))||/\.(mp3|m4a|aac|wav|flac|ogg)$/i.test(f.name)); audios.sort(numericFileSort);
      playlist=audios; currentTrack=0; audioPaused=true; playing=false; lcd(playlist.length?`LOADED ${playlist.length} files${label?' — '+label:''}`:'NO FILES'); }
    async function* walk(h){ for await (const [name,e] of h.entries()){ if(e.kind==='file') yield await e.getFile(); else if(e.kind==='directory') yield* walk(e);} }
    async function loadFromDir(h){ const files=[]; for await(const f of walk(h)) files.push(f); await replacePlaylist(files, h?.name||''); }
    async function pickFolderNative(){ const h=await window.showDirectoryPicker({mode:'read'}); const p=await h.requestPermission({mode:'read'}); if(p!=='granted') throw new DOMException('Permission denied');
      dirHandle=h; await idbSet('musicDir',h); await loadFromDir(h); }
    folderButton.addEventListener('click',async(e)=>{ e.preventDefault(); e.stopPropagation(); requestWakeLock();
      try{ if('showDirectoryPicker' in window){ await pickFolderNative(); } else { audioInput.click(); } }catch(err){ console.warn('Picker failed, fallback:',err); audioInput.click(); } });
    audioInput.addEventListener('change',async(e)=>{ const files=Array.from(e.target.files||[]); await idbDel('musicDir'); dirHandle=null; await replacePlaylist(files); });
    (async()=>{ try{ const h=await idbGet('musicDir'); if(!h||!('queryPermission' in h)) return; const st=await h.queryPermission({mode:'read'});
      if(st!=='granted'){ const p=await h.requestPermission({mode:'read'}); if(p!=='granted') return; } dirHandle=h; await loadFromDir(h);}catch{} })();

    /* ==== Background -> Foreground auto-resume with gesture fallback ==== */
    function currentOffset(){ if(!audioContext||!trackBuffer) return 0; return Math.max(0,(audioContext.currentTime-startedAtCtxTime)); }

    async function pauseForBackground(){
      if(playing && !audioPaused){
        pausedOffsetSec = currentOffset(); autoPausedByBackground = true;
        try{ await (audioContext?.suspend?.()); }catch{}
        audioPaused = true; lcd('PAUSED (background)');
      }
    }

    function gestureResumeSetup(){
      lcd(`TAP TO <strong>RESUME</strong> — TRACK ${currentTrack+1}/${playlist.length}: ${playlist[currentTrack]?.name||''}`);
      const once = async ()=>{
        document.removeEventListener('touchstart', once);
        document.removeEventListener('click', once);
        const off = pausedOffsetSec || 0; pausedOffsetSec=0; autoPausedByBackground=false;
        await playTrack(currentTrack, off);
      };
      document.addEventListener('touchstart', once, { once:true });
      document.addEventListener('click', once, { once:true });
    }

    async function tryAutoResume(){
      if(!autoPausedByBackground) return;
      autoPausedByBackground=false;
      ensureContext();
      try{
        await audioContext.resume();
        // If source lost, rebuild from offset
        if(!source){ const off = pausedOffsetSec||0; pausedOffsetSec=0; await playTrack(currentTrack, off); return; }
        audioPaused=false; playing=true; lcdTrack();
      }catch(e){
        // Some browsers require a gesture to resume
        gestureResumeSetup();
      }
    }

    document.addEventListener('visibilitychange',()=>{
      if(document.visibilityState==='hidden') pauseForBackground();
      if(document.visibilityState==='visible') setTimeout(tryAutoResume, 200); // small delay for Android
    });
    window.addEventListener('pagehide',()=>pauseForBackground());

    /* ========= Wake Lock ========= */
    let wakeLock=null, wakeRetryTimer=null;
    async function requestWakeLock(){ try{ if(!('wakeLock' in navigator)) return; if(wakeLock) return;
      wakeLock=await navigator.wakeLock.request('screen');
      if(!document.querySelector('#lcd small')) lcdSpan.insertAdjacentHTML('beforeend','<small>• screen on</small>');
      wakeLock.addEventListener('release',()=>{ wakeLock=null; clearTimeout(wakeRetryTimer); wakeRetryTimer=setTimeout(()=>{requestWakeLock();},500); });
    }catch(e){ clearTimeout(wakeRetryTimer); wakeRetryTimer=setTimeout(()=>{requestWakeLock();},1000);}}
    document.addEventListener('visibilitychange',()=>{ if(document.visibilityState==='visible') requestWakeLock(); });
    ['click','touchstart'].forEach(ev=>document.addEventListener(ev,requestWakeLock,{once:true}));

    /* MediaSession */
    if('mediaSession' in navigator){
      navigator.mediaSession.setActionHandler('play',async()=>{
        const off = pausedOffsetSec||0; pausedOffsetSec=0; autoPausedByBackground=false;
        if(!playlist.length) return; await playTrack(currentTrack, off);
      });
      navigator.mediaSession.setActionHandler('pause',async()=>{ pausedOffsetSec=currentOffset(); audioPaused=true; await softKill(); lcdPaused(); });
      navigator.mediaSession.setActionHandler('previoustrack',()=>backButton.click());
      navigator.mediaSession.setActionHandler('nexttrack',()=>skipButton.click());
    }
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js?ver=23').catch(console.error);
      });
    }
  </script>
</body>
</html>
