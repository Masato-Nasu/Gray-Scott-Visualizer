<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>Gray-Scott Visualizer (Minimal Fade-In)</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" href="./icon-192.png" type="image/png">
  <meta name="theme-color" content="#000000">
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #fff; font-family: system-ui, sans-serif;
           display: flex; flex-direction: column; align-items: center; padding: 16px; }
    canvas { background: #000; width: 100%; max-width: 500px; aspect-ratio: 1 / 1;
             border-radius: 4px; opacity: 0; transition: opacity 1s ease; pointer-events: none; }
    canvas.active { opacity: 1; pointer-events: auto; }
    #controls { display: flex; flex-direction: column; align-items: stretch; width: 100%;
                max-width: 500px; margin-top: 16px; gap: 8px; }
    #lcd, button { height: 48px; background: #111; border: 1px solid #444; color: #fff;
                   font-size: 16px; font-family: monospace; display: flex; align-items: center;
                   justify-content: center; white-space: nowrap; cursor: pointer; padding: 0 12px;
                   border-radius: 6px; overflow: hidden; text-overflow: ellipsis; }
    #lcd span { display: inline-block; animation: scroll 10s linear infinite; }
    @keyframes scroll { from { transform: translateX(100%); } to { transform: translateX(-100%); } }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <div id="lcd"><span>NO FILES LOADED</span></div>
    <button id="folderButton">SELECT MUSIC FOLDER / FILES</button>
    <button id="playButton">PLAY</button>
    <button id="pauseButton">PAUSE</button>
    <button id="skipButton">NEXT</button>
    <button id="backButton">PREVIOUS</button>
    <input type="file" id="audioInput" accept="audio/*" multiple webkitdirectory>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
  <script>
    /* ====== Gray-Scott visualizer ====== */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const size = 500;
    canvas.width = canvas.height = size;
    const imageData = ctx.createImageData(size, size);
    let canvasActivated = false;

    let U = new Float32Array(size * size).fill(1);
    let V = new Float32Array(size * size).fill(0);
    for (let y = size / 2 - 16; y < size / 2 + 16; y++)
      for (let x = size / 2 - 16; x < size / 2 + 16; x++)
        V[y * size + x] = 1;

    const du = 0.16, dv = 0.08;
    let playing = false;           // 現在のトラックがセットされ再生可能な状態か
    let audioPaused = false;       // 音声が一時停止中か
    let isSwitching = false;
    let flashFeed = 0, flashKill = 0;
    const pinkNoise = Array(8).fill(0);

    function generatePinkNoise() {
      let total = 0;
      for (let i = 0; i < pinkNoise.length; i++) {
        if (Math.random() < 1 / (1 << i)) pinkNoise[i] = Math.random() * 2 - 1;
        total += pinkNoise[i];
      }
      return total / pinkNoise.length;
    }
    function lap(f, x, y) {
      return f[((y - 1 + size) % size) * size + x] + f[((y + 1) % size) * size + x] +
             f[y * size + ((x - 1 + size) % size)] + f[y * size + ((x + 1) % size)] - 4 * f[y * size + x];
    }
    function step() {
      const U2 = new Float32Array(U.length), V2 = new Float32Array(V.length);
      const t = performance.now() / 1000;
      // 音声が止まっていても可視化は動かし続ける（速度はベース値）
      const pf = generatePinkNoise() * 0.0015, pk = generatePinkNoise() * 0.0015;
      const feedBase = 0.022, killBase = 0.051;
      const f = feedBase + pf + 0.0007 * Math.sin(t * Math.PI / 10) + flashFeed;
      const k = killBase + pk + 0.0007 * Math.cos(t * Math.PI / 10) + flashKill;
      flashFeed *= 0.85; flashKill *= 0.85;
      for (let i = 0; i < U.length; i++) {
        const y = Math.floor(i / size), x = i % size;
        const u = U[i], v = V[i];
        const Lu = lap(U, x, y) * 1.2;
        const Lv = lap(V, x, y) * 1.2;
        U2[i] = u + (du * Lu - u * v * v + f * (1 - u));
        V2[i] = v + (dv * Lv + u * v * v - (f + k) * v);
      }
      U = U2; V = V2;
    }
    function draw() {
      const d = imageData.data;
      const kTone = 3.0;
      const norm = x => Math.max(0, Math.min(1, x));
      const tone = x => (1 - Math.exp(-kTone * x)) / (1 - Math.exp(-kTone));
      for (let i = 0; i < U.length; i++) {
        const base = norm((U[i] - V[i]) * 1.0);
        const t = tone(base);
        const capped = Math.min(t, 0.92);
        const c = (capped * 255) | 0;
        const p = i * 4;
        d[p] = d[p + 1] = d[p + 2] = c; d[p + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
    }
    function loop() {
      // 可視化は常に進める（audioPausedでも継続）
      let speed = 3;
      // 将来：音量に応じた加速は playing && !audioPaused でのみ有効でもOK
      for (let i = 0; i < speed; i++) step();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    canvas.addEventListener('click', () => { flashFeed = 0.02; flashKill = -0.01; });

    /* ====== Audio playback ====== */
    let audioContext, source, meyda;
    let playlist = [], currentTrack = 0;
    let playSessionId = 0;
    const lcdSpan = document.querySelector('#lcd span');

    function setLCDPausedNote() {
      if (playlist.length) {
        lcdSpan.textContent = `PAUSED — TRACK ${currentTrack + 1}/${playlist.length}: ${playlist[currentTrack].name}`;
      } else {
        lcdSpan.textContent = 'PAUSED';
      }
    }
    function setLCDTrack() {
      lcdSpan.textContent = `TRACK ${currentTrack + 1}/${playlist.length}: ${playlist[currentTrack].name}`;
    }

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioContext.onstatechange = () => {
          // 電話/オーディオ経路変更などでsuspendされたら、明示的に停止状態へ
          if (audioContext.state === 'suspended' && playing && !audioPaused) {
            audioPaused = true;
            setLCDPausedNote();
          }
        };
      }
    }
    document.body.addEventListener('touchend', () => {
      if (audioContext?.state === 'suspended' && !audioPaused) audioContext.resume();
    }, { once: true });

    async function stopCurrentTrack() {
      if (source) {
        try { source.onended = null; } catch {}
        try { source.stop(); } catch {}
        try { source.disconnect(); } catch {}
        source = null;
      }
      await new Promise(r => setTimeout(r, 50));
    }
    async function loadAudioBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = evt => {
          audioContext.decodeAudioData(evt.target.result).then(resolve).catch(reject);
        };
        reader.readAsArrayBuffer(file);
      });
    }

    function numericFileSort(a, b) {
      const ra = a.name.match(/\d+/);
      const rb = b.name.match(/\d+/);
      if (ra && rb) {
        const na = parseInt(ra[0], 10);
        const nb = parseInt(rb[0], 10);
        if (na !== nb) return na - nb;
      } else if (ra && !rb) return -1;
      else if (!ra && rb) return 1;
      return a.name.localeCompare(b.name, 'ja', { numeric: true, sensitivity: 'base' });
    }
    function nextIndex(idx, dir=+1) {
      const n = playlist.length || 1;
      return (idx + dir + n) % n;
    }

    async function playTrack(index) {
      if (isSwitching || !playlist.length || index >= playlist.length || index < 0) return;
      isSwitching = true;
      const mySession = ++playSessionId;
      try {
        await stopCurrentTrack();
        initAudio();
        const file = playlist[index];
        const buffer = await loadAudioBuffer(file);
        if (!buffer) { lcdSpan.textContent = `Decode failed: ${file.name}`; return; }
        if (mySession !== playSessionId) return;

        source = audioContext.createBufferSource();
        source.buffer = buffer;
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        if (!meyda) {
          meyda = Meyda.createMeydaAnalyzer({
            audioContext, source: analyser, bufferSize: 512,
            featureExtractors: ['rms', 'spectralCentroid'],
            callback: f => { /* 可視化は内部ノイズで動いているため必須ではない */ }
          });
          meyda.start();
        } else {
          meyda.setSource(analyser);
        }

        source.onended = () => {
          if (mySession !== playSessionId) return;
          if (!audioPaused) {
            setTimeout(() => playTrack(nextIndex(currentTrack, +1)), 0);
          }
        };

        currentTrack = index;
        setLCDTrack();
        playing = true;
        audioPaused = false;
        await audioContext.resume();
        source.start(0);

        if (!canvasActivated) { canvas.classList.add('active'); canvasActivated = true; }

      } catch (e) {
        lcdSpan.textContent = `Error: ${e.message}`; console.error(e);
      } finally { isSwitching = false; }
    }

    document.getElementById('playButton').addEventListener('click', () => {
      if (!playlist.length) return;
      if (audioContext?.state === 'suspended') {
        audioPaused = false;
        audioContext.resume().then(() => setLCDTrack()).catch(()=>{});
      } else if (!source) {
        playTrack(currentTrack);
      } else {
        audioPaused = false;
        audioContext.resume().then(() => setLCDTrack()).catch(()=>{});
      }
    });
    document.getElementById('pauseButton').addEventListener('click', () => {
      if (!audioContext) return;
      try { audioContext.suspend(); } catch {}
      audioPaused = true;
      setLCDPausedNote();
    });
    document.getElementById('skipButton').addEventListener('click', async () => {
      if (isSwitching || !playlist.length) return;
      await stopCurrentTrack(); if (audioContext) await audioContext.resume();
      await playTrack(nextIndex(currentTrack, +1));
    });
    document.getElementById('backButton').addEventListener('click', async () => {
      if (isSwitching || !playlist.length) return;
      await stopCurrentTrack(); if (audioContext) await audioContext.resume();
      await playTrack(nextIndex(currentTrack, -1));
    });

    /* ====== Picker (cross‑platform) ====== */
    const folderButton = document.getElementById('folderButton');
    const audioInput = document.getElementById('audioInput');
    function idbSet(key, value) {
      return new Promise((resolve, reject) => {
        const open = indexedDB.open('gsv-db', 1);
        open.onupgradeneeded = () => open.result.createObjectStore('s');
        open.onsuccess = () => {
          const tx = open.result.transaction('s', 'readwrite');
          tx.objectStore('s').put(value, key);
          tx.oncomplete = () => resolve();
          tx.onerror = reject;
        };
        open.onerror = reject;
      });
    }
    function idbGet(key) {
      return new Promise((resolve, reject) => {
        const open = indexedDB.open('gsv-db', 1);
        open.onupgradeneeded = () => open.result.createObjectStore('s');
        open.onsuccess = () => {
          const tx = open.result.transaction('s', 'readonly');
          const req = tx.objectStore('s').get(key);
          req.onsuccess = () => resolve(req.result);
          req.onerror = reject;
        };
        open.onerror = reject;
      });
    }

    let dirHandle;
    async function pickFolderNative() {
      dirHandle = await window.showDirectoryPicker({ mode: 'read' });
      const perm = await dirHandle.requestPermission({ mode: 'read' });
      if (perm !== 'granted') throw new DOMException('Permission denied');
      await idbSet('musicDir', dirHandle);
      await loadFromDirectoryHandle(dirHandle);
    }
    async function* iterateFilesRecursively(handle) {
      for await (const [name, entry] of handle.entries()) {
        if (entry.kind === 'file') yield await entry.getFile();
        else if (entry.kind === 'directory') yield* iterateFilesRecursively(entry);
      }
    }
    async function loadFromDirectoryHandle(handle) {
      let files = [];
      for await (const f of iterateFilesRecursively(handle)) files.push(f);
      ingestFiles(files);
    }
    function ingestFiles(files) {
      const audios = files.filter(f => (f.type && f.type.startsWith('audio/')) || /\.(mp3|m4a|aac|wav|flac|ogg)$/i.test(f.name));
      audios.sort(numericFileSort);
      playlist = audios;
      currentTrack = 0;
      if (playlist.length) setLCDTrack(); else lcdSpan.textContent = 'NO FILES';
    }
    folderButton.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      try {
        if ('showDirectoryPicker' in window) {
          await pickFolderNative(); // Desktop
        } else {
          audioInput.click();       // Android / iOS
        }
      } catch (err) {
        console.warn('Picker failed, fallback to input:', err);
        audioInput.click();
      }
    });
    audioInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files || []);
      ingestFiles(files);
    });
    (async () => {
      try {
        const h = await idbGet('musicDir');
        if (!h || !('queryPermission' in h)) return;
        const status = await h.queryPermission({ mode: 'read' });
        if (status !== 'granted') {
          const p = await h.requestPermission({ mode: 'read' });
          if (p !== 'granted') return;
        }
        dirHandle = h; await loadFromDirectoryHandle(h);
      } catch {}
    })();

    /* ====== Background policy (no auto-resume) ====== */
    function autoPause(reason) {
      try { if (audioContext?.state === 'running') audioContext.suspend(); } catch {}
      audioPaused = true;
      if (reason === 'background') {
        // 復帰後に「PAUSED — TRACK…」へ差し替えるので一時的な文言
        lcdSpan.textContent = 'PAUSED (background)';
      } else {
        setLCDPausedNote();
      }
    }
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') autoPause('background');
      if (document.visibilityState === 'visible' && audioPaused) {
        // 自動再生はしない。表示だけ整える。
        if (playlist.length) setLCDPausedNote();
      }
    });
    window.addEventListener('pagehide', () => autoPause('background'));

    /* ====== MediaSession ====== */
    if ('mediaSession' in navigator) {
      navigator.mediaSession.setActionHandler('play', () => {
        if (!playlist.length) return;
        audioPaused = false;
        audioContext?.resume().then(setLCDTrack).catch(()=>{});
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        audioPaused = true;
        try { audioContext?.suspend(); } catch {}
        setLCDPausedNote();
      });
      navigator.mediaSession.setActionHandler('previoustrack', () => { document.getElementById('backButton').click(); });
      navigator.mediaSession.setActionHandler('nexttrack', () => { document.getElementById('skipButton').click(); });
    }
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js?ver=15').catch(console.error);
      });
    }
  </script>
</body>
</html>
