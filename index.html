<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>Gray-Scott Visualizer (Minimal Fade-In)</title>
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" href="./icon-192.png" type="image/png">
  <meta name="theme-color" content="#000000">
  <style>
    html, body { height: 100%; }
    body { margin: 0; background: #000; color: #fff; font-family: system-ui, sans-serif;
           display: flex; flex-direction: column; align-items: center; padding: 16px; }
    canvas { background: #000; width: 100%; max-width: 500px; aspect-ratio: 1 / 1;
             border-radius: 6px; opacity: 0; transition: opacity 0.8s ease; pointer-events: none; }
    canvas.active { opacity: 1; pointer-events: auto; }
    #controls { display: flex; flex-direction: column; align-items: stretch; width: 100%;
                max-width: 500px; margin-top: 16px; gap: 8px; }
    #lcd, button { height: 48px; background: #111; border: 1px solid #444; color: #fff;
                   font-size: 16px; font-family: monospace; display: flex; align-items: center;
                   justify-content: center; white-space: nowrap; cursor: pointer; padding: 0 12px;
                   border-radius: 8px; overflow: hidden; text-overflow: ellipsis; }
    #lcd span { display: inline-block; animation: scroll 12s linear infinite; }
    @keyframes scroll { from { transform: translateX(100%); } to { transform: translateX(-100%); } }
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <div id="lcd"><span>NO FILES LOADED</span></div>
    <button id="folderButton">SELECT MUSIC FOLDER / FILES</button>
    <button id="playButton">PLAY</button>
    <button id="pauseButton">PAUSE</button>
    <button id="skipButton">NEXT</button>
    <button id="backButton">PREVIOUS</button>
    <input type="file" id="audioInput" accept="audio/*" multiple webkitdirectory>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
  <script>
    /* ================== Gray-Scott 可視化 ================== */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const size = 500;
    canvas.width = canvas.height = size;
    const imageData = ctx.createImageData(size, size);
    let canvasActivated = false;

    let U = new Float32Array(size * size).fill(1);
    let V = new Float32Array(size * size).fill(0);
    for (let y = size / 2 - 16; y < size / 2 + 16; y++)
      for (let x = size / 2 - 16; x < size / 2 + 16; x++)
        V[y * size + x] = 1;

    const du = 0.16, dv = 0.08;
    let audioPaused = true;   // 音声の一時停止状態（手動再開まで続く）
    let isSwitching = false;
    let flashFeed = 0, flashKill = 0;
    const pinkNoise = Array(8).fill(0);

    function generatePinkNoise() {
      let total = 0;
      for (let i = 0; i < pinkNoise.length; i++) {
        if (Math.random() < 1 / (1 << i)) pinkNoise[i] = Math.random() * 2 - 1;
        total += pinkNoise[i];
      }
      return total / pinkNoise.length;
    }
    function lap(f, x, y) {
      return f[((y - 1 + size) % size) * size + x] + f[((y + 1) % size) * size + x] +
             f[y * size + ((x - 1 + size) % size)] + f[y * size + ((x + 1) % size)] - 4 * f[y * size + x];
    }
    function step() {
      const U2 = new Float32Array(U.length), V2 = new Float32Array(V.length);
      const t = performance.now() / 1000;
      const pf = generatePinkNoise() * 0.0015, pk = generatePinkNoise() * 0.0015;
      const feedBase = 0.022, killBase = 0.051;
      const f = feedBase + pf + 0.0007 * Math.sin(t * Math.PI / 10) + flashFeed;
      const k = killBase + pk + 0.0007 * Math.cos(t * Math.PI / 10) + flashKill;
      flashFeed *= 0.85; flashKill *= 0.85;
      for (let i = 0; i < U.length; i++) {
        const y = Math.floor(i / size), x = i % size;
        const u = U[i], v = V[i];
        const Lu = lap(U, x, y) * 1.2;
        const Lv = lap(V, x, y) * 1.2;
        U2[i] = u + (du * Lu - u * v * v + f * (1 - u));
        V2[i] = v + (dv * Lv + u * v * v - (f + k) * v);
      }
      U = U2; V = V2;
    }
    function draw() {
      const d = imageData.data;
      const kTone = 3.0;
      const norm = x => Math.max(0, Math.min(1, x));
      const tone = x => (1 - Math.exp(-kTone * x)) / (1 - Math.exp(-kTone));
      for (let i = 0; i < U.length; i++) {
        const base = norm((U[i] - V[i]) * 1.0);
        const t = tone(base);
        const capped = Math.min(t, 0.92);
        const c = (capped * 255) | 0;
        const p = i * 4;
        d[p] = d[p + 1] = d[p + 2] = c; d[p + 3] = 255;
      }
      ctx.putImageData(imageData, 0, 0);
    }
    function loop() {
      // 音声とは独立して常に可視化を進める
      let speed = 3;
      for (let i = 0; i < speed; i++) step();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    canvas.addEventListener('click', () => { flashFeed = 0.02; flashKill = -0.01; });

    /* ================== Audio 再生 ================== */
    let audioContext, source, meyda;
    let playlist = [], currentTrack = 0, playing = false;
    let playSessionId = 0;
    const lcdSpan = document.querySelector('#lcd span');

    function lcd(text) { lcdSpan.textContent = text; }
    function lcdTrack() {
      if (!playlist.length) lcd('NO FILES');
      else lcd(`TRACK ${currentTrack + 1}/${playlist.length}: ${playlist[currentTrack].name}`);
    }
    function lcdPaused() {
      if (!playlist.length) lcd('PAUSED');
      else lcd(`PAUSED — TRACK ${currentTrack + 1}/${playlist.length}: ${playlist[currentTrack].name}`);
    }

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioContext.onstatechange = () => {
          // イヤホン抜けや通話で suspend された場合も「停止扱い」にする
          if (audioContext.state === 'suspended' && playing && !audioPaused) {
            audioPaused = true;
            lcdPaused();
          }
        };
      }
    }
    document.body.addEventListener('touchend', () => {
      if (audioContext?.state === 'suspended' && !audioPaused) audioContext.resume();
    }, { once: true });

    async function stopCurrentTrack() {
      if (source) {
        try { source.onended = null; } catch {}
        try { source.stop(); } catch {}
        try { source.disconnect(); } catch {}
        source = null;
      }
      playing = false;
      await new Promise(r => setTimeout(r, 30));
    }
    async function loadAudioBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = evt => {
          audioContext.decodeAudioData(evt.target.result).then(resolve).catch(reject);
        };
        reader.readAsArrayBuffer(file);
      });
    }

    function numericFileSort(a, b) {
      const ra = a.name.match(/\d+/);
      const rb = b.name.match(/\d+/);
      if (ra && rb) {
        const na = parseInt(ra[0], 10), nb = parseInt(rb[0], 10);
        if (na !== nb) return na - nb;
      } else if (ra && !rb) return -1;
      else if (!ra && rb) return 1;
      return a.name.localeCompare(b.name, 'ja', { numeric: true, sensitivity: 'base' });
    }
    function nextIndex(idx, dir=+1) { const n = playlist.length || 1; return (idx + dir + n) % n; }

    async function playTrack(index) {
      if (isSwitching || !playlist.length || index < 0 || index >= playlist.length) return;
      isSwitching = true;
      const mySession = ++playSessionId;
      try {
        await stopCurrentTrack();
        initAudio();

        const file = playlist[index];
        const buffer = await loadAudioBuffer(file);
        if (mySession !== playSessionId) return;

        source = audioContext.createBufferSource();
        source.buffer = buffer;

        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        if (!meyda) {
          meyda = Meyda.createMeydaAnalyzer({
            audioContext, source: analyser, bufferSize: 512,
            featureExtractors: ['rms', 'spectralCentroid'],
            callback: () => {} // 可視化は内部ノイズで十分
          });
          meyda.start();
        } else {
          meyda.setSource(analyser);
        }

        source.onended = () => {
          if (mySession !== playSessionId) return;
          if (!audioPaused) setTimeout(() => playTrack(nextIndex(currentTrack, +1)), 0);
        };

        currentTrack = index;
        lcdTrack();
        playing = true;
        audioPaused = false;
        await audioContext.resume();
        source.start(0);

        if (!canvasActivated) { canvas.classList.add('active'); canvasActivated = true; }

      } catch (e) {
        lcd(`Error: ${e.message}`); console.error(e);
      } finally { isSwitching = false; }
    }

    /* ===== controls ===== */
    document.getElementById('playButton').addEventListener('click', () => {
      if (!playlist.length) return;
      if (!source) playTrack(currentTrack);
      else {
        audioPaused = false;
        audioContext?.resume().then(lcdTrack).catch(()=>{});
      }
    });
    document.getElementById('pauseButton').addEventListener('click', () => {
      if (!audioContext) return;
      try { audioContext.suspend(); } catch {}
      audioPaused = true; lcdPaused();
    });
    document.getElementById('skipButton').addEventListener('click', async () => {
      if (!playlist.length) return;
      await stopCurrentTrack(); if (audioContext) await audioContext.resume();
      await playTrack(nextIndex(currentTrack, +1));
    });
    document.getElementById('backButton').addEventListener('click', async () => {
      if (!playlist.length) return;
      await stopCurrentTrack(); if (audioContext) await audioContext.resume();
      await playTrack(nextIndex(currentTrack, -1));
    });

    /* ================== Picker（クロスプラットフォーム） ================== */
    const folderButton = document.getElementById('folderButton');
    const audioInput = document.getElementById('audioInput');

    function idbOpen() {
      return new Promise((resolve, reject) => {
        const open = indexedDB.open('gsv-db', 1);
        open.onupgradeneeded = () => open.result.createObjectStore('s');
        open.onsuccess = () => resolve(open.result);
        open.onerror = reject;
      });
    }
    async function idbSet(key, value) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('s', 'readwrite');
        tx.objectStore('s').put(value, key);
        tx.oncomplete = resolve;
        tx.onerror = reject;
      });
    }
    async function idbGet(key) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('s', 'readonly');
        const req = tx.objectStore('s').get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = reject;
      });
    }
    async function idbDel(key) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('s', 'readwrite');
        tx.objectStore('s').delete(key);
        tx.oncomplete = resolve;
        tx.onerror = reject;
      });
    }

    let dirHandle;
    let loadSession = 0;

    async function replacePlaylistWith(files, label='') {
      const myLoad = ++loadSession;  // 直前のロードを無効化
      await stopCurrentTrack();      // 再生中なら必ず停止
      const audios = files.filter(f => (f.type && f.type.startsWith('audio/')) || /\.(mp3|m4a|aac|wav|flac|ogg)$/i.test(f.name));
      audios.sort(numericFileSort);
      if (myLoad !== loadSession) return;
      playlist = audios;
      currentTrack = 0;
      audioPaused = true;
      if (playlist.length) lcd(`LOADED ${playlist.length} files${label ? ' — ' + label : ''}`);
      else lcd('NO FILES');
    }

    async function* iterateFilesRecursively(handle) {
      for await (const [name, entry] of handle.entries()) {
        if (entry.kind === 'file') yield await entry.getFile();
        else if (entry.kind === 'directory') yield* iterateFilesRecursively(entry);
      }
    }
    async function loadFromDirectoryHandle(handle) {
      const files = [];
      for await (const f of iterateFilesRecursively(handle)) files.push(f);
      await replacePlaylistWith(files, handle?.name || '');
    }

    async function pickFolderNative() {
      const h = await window.showDirectoryPicker({ mode: 'read' });
      const perm = await h.requestPermission({ mode: 'read' });
      if (perm !== 'granted') throw new DOMException('Permission denied');
      dirHandle = h;
      await idbSet('musicDir', h);           // 常に上書き
      await loadFromDirectoryHandle(h);
    }

    folderButton.addEventListener('click', async (e) => {
      e.preventDefault(); e.stopPropagation();
      try {
        if ('showDirectoryPicker' in window) {
          await pickFolderNative();          // デスクトップ：フォルダ直接
        } else {
          audioInput.click();                // モバイル：ファイル複数選択
        }
      } catch (err) {
        console.warn('Picker failed, fallback to input:', err);
        audioInput.click();
      }
    });

    audioInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files || []);
      await idbDel('musicDir');              // モバイルはフォルダ保持できないため復元情報を消す
      dirHandle = null;
      await replacePlaylistWith(files);
    });

    // 起動時復元（PCのみ効果あり）
    (async () => {
      try {
        const h = await idbGet('musicDir');
        if (!h || !('queryPermission' in h)) return;
        const status = await h.queryPermission({ mode: 'read' });
        if (status !== 'granted') {
          const p = await h.requestPermission({ mode: 'read' });
          if (p !== 'granted') return;
        }
        dirHandle = h; await loadFromDirectoryHandle(h);
      } catch {}
    })();

    /* ================== 背景化ポリシー（自動再開しない） ================== */
    function autoPause(reason) {
      try { if (audioContext?.state === 'running') audioContext.suspend(); } catch {}
      audioPaused = true;
      if (reason === 'background') lcd('PAUSED (background)'); else lcdPaused();
    }
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') autoPause('background');
      if (document.visibilityState === 'visible' && audioPaused) {
        // 復帰時は "(background)" を通常の PAUSED 表示へ正規化
        lcdPaused();
      }
    });
    window.addEventListener('pagehide', () => autoPause('background'));

    /* ================== MediaSession ================== */
    if ('mediaSession' in navigator) {
      navigator.mediaSession.setActionHandler('play', () => {
        if (!playlist.length) return;
        audioPaused = false;
        audioContext?.resume().then(lcdTrack).catch(()=>{});
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        audioPaused = true;
        try { audioContext?.suspend(); } catch {}
        lcdPaused();
      });
      navigator.mediaSession.setActionHandler('previoustrack', () => { document.getElementById('backButton').click(); });
      navigator.mediaSession.setActionHandler('nexttrack', () => { document.getElementById('skipButton').click(); });
    }
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js?ver=16').catch(console.error);
      });
    }
  </script>
</body>
</html>
